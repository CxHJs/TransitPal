// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stations.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// -*- mode: proto; indent-tabs-mode: nil; tab-width: 4 -*-

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum TransportType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case bus // = 1
  case train // = 2
  case tram // = 3
  case metro // = 4
  case ferry // = 5
  case ticketMachine // = 6
  case vendingMachine // = 7
  case pos // = 8
  case other // = 9
  case banned // = 10
  case trolleybus // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .bus
    case 2: self = .train
    case 3: self = .tram
    case 4: self = .metro
    case 5: self = .ferry
    case 6: self = .ticketMachine
    case 7: self = .vendingMachine
    case 8: self = .pos
    case 9: self = .other
    case 10: self = .banned
    case 11: self = .trolleybus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .bus: return 1
    case .train: return 2
    case .tram: return 3
    case .metro: return 4
    case .ferry: return 5
    case .ticketMachine: return 6
    case .vendingMachine: return 7
    case .pos: return 8
    case .other: return 9
    case .banned: return 10
    case .trolleybus: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TransportType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TransportType] = [
    .unknown,
    .bus,
    .train,
    .tram,
    .metro,
    .ferry,
    .ticketMachine,
    .vendingMachine,
    .pos,
    .other,
    .banned,
    .trolleybus,
  ]
}

#endif  // swift(>=4.2)

///
/// This is the header, which appears prefixed with a varint, 12 bytes after the start of the file.
public struct StationDb {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version number for the data in this file (not the schema).
  public var version: UInt64 = 0

  /// Language codes (two-letter ISO code) where we should show the "local_name"
  /// instead of the english_name.
  public var localLanguages: [String] = []

  /// All operators / companies in the network.
  public var operators: Dictionary<UInt32,Operator> = [:]

  /// All rail lines in the network.
  public var lines: Dictionary<UInt32,Line> = [:]

  /// Provides a hint for LocaleSpan about which language to mark up the
  /// names with, to improve pronunciation.
  public var ttsHintLanguage: String = String()

  /// Licensing notice for the file.
  public var licenseNotice: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Names {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var english: String = String()

  public var local: String = String()

  public var englishShort: String = String()

  public var localShort: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Operator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Names {
    get {return _storage._name ?? Names()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  /// Default transport type provided by this operator.
  public var defaultTransport: TransportType {
    get {return _storage._defaultTransport}
    set {_uniqueStorage()._defaultTransport = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Line {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Names {
    get {return _storage._name ?? Names()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  public var transport: TransportType {
    get {return _storage._transport}
    set {_uniqueStorage()._transport = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct City {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
/// The second part of the file is a series of Station messages, prefixed with a varint describing
/// each records' length.
///
/// In Suica's case, this is 242493 bytes (41 bytes per record).
public struct Station {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the station (as appears in the index).
  ///
  /// Note: The only way to key a station is by ID. If you require multiple integers to identify a
  /// station (eg: agency + line + station), then these need to be packed together. In order to
  /// minimise file size, the integers should be lower.
  public var id: UInt32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var name: Names {
    get {return _storage._name ?? Names()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  /// The location of the station, in WGS84 datum.
  /// If latitude and longitude are both set to 0, it is presumed that it is
  /// unset.
  public var latitude: Float {
    get {return _storage._latitude}
    set {_uniqueStorage()._latitude = newValue}
  }

  public var longitude: Float {
    get {return _storage._longitude}
    set {_uniqueStorage()._longitude = newValue}
  }

  /// The ID of the operator (from StationDb.operators).
  public var operatorID: UInt32 {
    get {return _storage._operatorID}
    set {_uniqueStorage()._operatorID = newValue}
  }

  /// The ID of the line (from StationDb.lines).
  public var lineID: [UInt32] {
    get {return _storage._lineID}
    set {_uniqueStorage()._lineID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///
/// Map of all the stations that appear in this file.
///
/// With 5911 stations (for Suica), this message comes out to 56283 bytes long
/// (average map entry size is ~9.5 bytes)
public struct StationIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This map goes from station_id -> station_offset.  This is a byte offset,
  /// relative to the end of the StationDb message.  ie: if StationDb finishes
  /// at byte 1234, and the station is at byte 4567, the offset here will be
  /// 3333.
  public var stationMap: Dictionary<UInt32,UInt32> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension TransportType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BUS"),
    2: .same(proto: "TRAIN"),
    3: .same(proto: "TRAM"),
    4: .same(proto: "METRO"),
    5: .same(proto: "FERRY"),
    6: .same(proto: "TICKET_MACHINE"),
    7: .same(proto: "VENDING_MACHINE"),
    8: .same(proto: "POS"),
    9: .same(proto: "OTHER"),
    10: .same(proto: "BANNED"),
    11: .same(proto: "TROLLEYBUS"),
  ]
}

extension StationDb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StationDb"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "local_languages"),
    3: .same(proto: "operators"),
    4: .same(proto: "lines"),
    5: .standard(proto: "tts_hint_language"),
    6: .standard(proto: "license_notice"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.version)
      case 2: try decoder.decodeRepeatedStringField(value: &self.localLanguages)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Operator>.self, value: &self.operators)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Line>.self, value: &self.lines)
      case 5: try decoder.decodeSingularStringField(value: &self.ttsHintLanguage)
      case 6: try decoder.decodeSingularStringField(value: &self.licenseNotice)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.localLanguages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.localLanguages, fieldNumber: 2)
    }
    if !self.operators.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Operator>.self, value: self.operators, fieldNumber: 3)
    }
    if !self.lines.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Line>.self, value: self.lines, fieldNumber: 4)
    }
    if !self.ttsHintLanguage.isEmpty {
      try visitor.visitSingularStringField(value: self.ttsHintLanguage, fieldNumber: 5)
    }
    if !self.licenseNotice.isEmpty {
      try visitor.visitSingularStringField(value: self.licenseNotice, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StationDb, rhs: StationDb) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.localLanguages != rhs.localLanguages {return false}
    if lhs.operators != rhs.operators {return false}
    if lhs.lines != rhs.lines {return false}
    if lhs.ttsHintLanguage != rhs.ttsHintLanguage {return false}
    if lhs.licenseNotice != rhs.licenseNotice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Names: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Names"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "english"),
    2: .same(proto: "local"),
    3: .standard(proto: "english_short"),
    4: .standard(proto: "local_short"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.english)
      case 2: try decoder.decodeSingularStringField(value: &self.local)
      case 3: try decoder.decodeSingularStringField(value: &self.englishShort)
      case 4: try decoder.decodeSingularStringField(value: &self.localShort)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.english.isEmpty {
      try visitor.visitSingularStringField(value: self.english, fieldNumber: 1)
    }
    if !self.local.isEmpty {
      try visitor.visitSingularStringField(value: self.local, fieldNumber: 2)
    }
    if !self.englishShort.isEmpty {
      try visitor.visitSingularStringField(value: self.englishShort, fieldNumber: 3)
    }
    if !self.localShort.isEmpty {
      try visitor.visitSingularStringField(value: self.localShort, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Names, rhs: Names) -> Bool {
    if lhs.english != rhs.english {return false}
    if lhs.local != rhs.local {return false}
    if lhs.englishShort != rhs.englishShort {return false}
    if lhs.localShort != rhs.localShort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Operator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Operator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
    4: .standard(proto: "default_transport"),
  ]

  fileprivate class _StorageClass {
    var _name: Names? = nil
    var _defaultTransport: TransportType = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _defaultTransport = source._defaultTransport
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 3: try decoder.decodeSingularMessageField(value: &_storage._name)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._defaultTransport)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._defaultTransport != .unknown {
        try visitor.visitSingularEnumField(value: _storage._defaultTransport, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Operator, rhs: Operator) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._defaultTransport != rhs_storage._defaultTransport {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Line: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Line"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
    4: .same(proto: "transport"),
  ]

  fileprivate class _StorageClass {
    var _name: Names? = nil
    var _transport: TransportType = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _transport = source._transport
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 3: try decoder.decodeSingularMessageField(value: &_storage._name)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._transport)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._transport != .unknown {
        try visitor.visitSingularEnumField(value: _storage._transport, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Line, rhs: Line) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._transport != rhs_storage._transport {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension City: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "City"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: City, rhs: City) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Station: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Station"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    8: .same(proto: "name"),
    4: .same(proto: "latitude"),
    5: .same(proto: "longitude"),
    6: .standard(proto: "operator_id"),
    7: .standard(proto: "line_id"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt32 = 0
    var _name: Names? = nil
    var _latitude: Float = 0
    var _longitude: Float = 0
    var _operatorID: UInt32 = 0
    var _lineID: [UInt32] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _latitude = source._latitude
      _longitude = source._longitude
      _operatorID = source._operatorID
      _lineID = source._lineID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._id)
        case 4: try decoder.decodeSingularFloatField(value: &_storage._latitude)
        case 5: try decoder.decodeSingularFloatField(value: &_storage._longitude)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._operatorID)
        case 7: try decoder.decodeRepeatedUInt32Field(value: &_storage._lineID)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._name)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._latitude != 0 {
        try visitor.visitSingularFloatField(value: _storage._latitude, fieldNumber: 4)
      }
      if _storage._longitude != 0 {
        try visitor.visitSingularFloatField(value: _storage._longitude, fieldNumber: 5)
      }
      if _storage._operatorID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._operatorID, fieldNumber: 6)
      }
      if !_storage._lineID.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._lineID, fieldNumber: 7)
      }
      if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Station, rhs: Station) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._operatorID != rhs_storage._operatorID {return false}
        if _storage._lineID != rhs_storage._lineID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StationIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StationIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "station_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufUInt32>.self, value: &self.stationMap)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stationMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufUInt32>.self, value: self.stationMap, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StationIndex, rhs: StationIndex) -> Bool {
    if lhs.stationMap != rhs.stationMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
